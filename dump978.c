#include <stdio.h>
#include <stdlib.h>
#include <math.h>


int main(int argc, char *argv[])
{
    // check a file was passed in as an argument
    if (argc < 2)
    {
        printf("specify name of the file to process\n");
        exit(EXIT_FAILURE);
    }
    
    // open file
    FILE *fp;
    fp = fopen(argv[1], "r");
    if (!fp)
    {
        printf("error opening file\n");
        exit(EXIT_FAILURE);
    }
    
    // get size of the file
    fseek(fp, 0L, SEEK_END);
    int fsize = (int) ftell(fp);
    fseek(fp, 0L, SEEK_SET);
    printf("size of file is %d bytes\n", fsize);
    
    // allocate double buffer for iq samples
    int size = fsize/2;
    double* i_buff = (double*) calloc(size, sizeof(double));
    double* q_buff = (double*) calloc(size, sizeof(double));
    
    // convert samples to signed floating point and save them into the buffers
    unsigned char i_char, q_char;
    double i_double, q_double;
    int i;
    for (i = 0; i < size; i++)
    {
        // read i and q samples from the file
        i_char = fgetc(fp);
        q_char = fgetc(fp);
        
        // convert samples to a signed floating point in the range [-1.0, 1.0]
        i_double = (i_char - 127.5) / 127.5;
        q_double = (q_char - 127.5) / 127.5;
        
        // save them into the allocated buffers
        i_buff[i] = i_double;
        q_buff[i] = q_double;
    }
    
    // close file
    fclose(fp);
    
    // allocate buffer for phase calculation results
    double* theta_buff = (double*) calloc(size, sizeof(double));
    
    // calculate phase for each iq sample
    for (i = 0; i < size; i++)
    {
        theta_buff[i] = atan2(q_buff[i], i_buff[i]);
    }
    
    // unwrap phase angle -> make it continuous
    for (i = 1; i < size; i++)
    {
        while (theta_buff[i] < theta_buff[i-1] - M_PI)
        {
            theta_buff[i] += 2.0 * M_PI;
        }
        while (theta_buff[i] > theta_buff[i-1] + M_PI)
        {
            theta_buff[i] -= 2 * M_PI;
        }
    }
    
    // allocate buffer for phase changes
    double* delta_buff = (double*) calloc(size-1, sizeof(double));
    
    // calculate change in phase
    for (i = 0; i < size-1; i++)
    {
        delta_buff[i] = theta_buff[i+1] - theta_buff[i];
    }
    
    // decode bits
    for (i = 433855; i < 442770; i+=2)
    {
        if (delta_buff[i] > 0)
        {
            printf("1");
        }
        else if (delta_buff[i] < 0)
        {
            printf("0");
        }
        else
        {
            printf("-E-");
        }
    }
    printf("\n");
    
    //  000101010011001000100101101100011101
    //000101010011001000100101101100011101001110111111000100000010000000010011000000000100111111110011111100110000000001000000010010000000000101110000010000000100100000000111011000000000011111011000000001101000000000000001110011111100001100000000000000001100111111001111000100000010001100101111110011110001000000100011111100110000101010110000001000111111001100000000010000000100110000000011000000000100000001001000000010011001000001000000010010000000010110000000000001000110100000000010011100000000001110101111110011110001000000000000001111111100111100010000001000000011111111001111000100000010001111110011000000000100000000100000111100110000000001000000010010000000001100000000010000000100100000000111011100000000000001001000000001101001000000001101111011111100011110010000000011001110111111001111000100000010101000001111110011110001000000100011111100110000111100010000001000111111001100000000010000000100001111110011000000000100000001001000000000111111000001000000010010000000010101100000000010011110100000000110110100000000011110001111110011110001000000000101001011111100111100010000001000111111111111001111000100000010000111110011000000000100000000100011111100110000000001000000010010000000001100000000010000000100100000000100101000000000000001001000000000101010000000000010101011111100011000010000000010000111111111001111000100000010000001001111110011110001000000100011111100110000111100010000001000001111001100000000010000000100001111110011000000000100000001001000000010010011000001000000010010000000010101000000000011111111100000000110101100000000101101101111110011110001000000001001000011111100111100010000001000001111111111001111000100000010000111110011000000000100000000100011111100110000000001000000010010000000001100000000010000000100100000000001100000000000000001001000000000101100000000001111010011111100011000100000000001001001111111001111000100000010110001101111110011110001000000100000001100110000111100010000001000001111001100000000010000000100001111110011000000000100000001001000000000111100000001000000010010000000001011110000000000011010100000000110010000000000110011011111110011110001000000001000100011111100111100010000001000111111111111001111000100000010000011110011000000000100000000100011111100110000000001000000010010000000001100000000010000000100100000000001011100000000000001001000000001101111000000000011001011111100011101000000000000010100111111001111000100000010010110101111110011110001000000100000001100110000111100010000001000111111001100000000010000000100001111110011000000000100000001001000000000111010000001000000010010000000010100010000000001011000100000000110011000000000001100101111110011110001000000000100101011111100111100010000001000111111111111001111000100000010000111110011000000000100000000100011111100110000000001000000010010000000001100000000010000000100100000001010001000000000000001001000000000101110000000000001000011111100011100100000000000001011111111001111000100000010100110001111110011110001000000100000001100110000111100010000001000001111001100000000010000000100001111110011000000000100000001001000000000111000000001000000010010000000010011110000000010010110100000000010100000000000011100001111110011110001000000001100010111111100111100010000001000111111111111001111000100000010000111110011000000000000000000100000111100110000000001000000010000000000001100000000010000000100100000000100001100000000000001001000000000001110000000000010001000000000011100000000000001101001111111001111000100000000110101101111110011110001000000100011111100000000110011001011111010001111011010000000010101100111100100001011111111001100000000100000101110100111110100111010011010100100100111010011110101010011000001110110000001001100010100101001111010001111100110011101001110101100010110000100110110111110100010111001000110001110011110000000110100001001010011100001010111010001100011100101000110010001111001110111010001110000000101010100010011010010000110100100111001001111011011001101001101000010000000011000100011010110011110010111111110000100011001010110100101101001101100101001001110100000010011001101100000001101100001101000101001010011100010100001101000101000011110111011011011100101000110110100001010010011011010000010111101011000100101000111110100101101011101011100010100000000111110010110011000000101110100001011001001111010101010010111101001100111010110010010011100011101100110111111101010000010001110010000011111001100101111100000000000101101111011101111101010001001000000100000111100000011001011000011110001000101010111
    
    //  15 32 25 b1 d3 bf 10 20 13 00 4f f3 f3 00 40 48 01 70 40 48 07 60 07 d8 06 80 01 cf c3 00 00 cf cf 10 23 2f cf 10 23 f3 0a b0 23 f3 00 40 4c 03 00 40 48 09 90 40 48 05 80 04 68 02 70 03 af cf 10 00 3f cf 10 20 3f cf 10 23 f3 00 40 20 f3 00 40 48 03 00 40 48 07 70 00 48 06 90 0d ef c7 90 0c ef cf 10 2a 0f cf 10 23 f3 0f 10 23 f3 00 40 43 f3 00 40 48 03 f0 40 48 05 60 09 e8 06 d0 07 8f cf 10 05 2f cf 10 23 ff cf 10 21 f3 00 40 23 f3 00 40 48 03 00 40 48 04 a0 00 48 02 a0 02 af c6 10 08 7f cf 10 20 4f cf 10 23 f3 0f 10 20 f3 00 40 43 f3 00 40 48 09 30 40 48 05 40 0f f8 06 b0 0b 6f cf 10 09 0f cf 10 20 ff cf 10 21 f3 00 40 23 f3 00 40 48 03 00 40 48 01 80 00 48 02 c0 0f 4f c6 20 04 9f cf 10 2c 6f cf 10 20 33 0f 10 20 f3 00 40 43 f3 00 40 48 03 c0 40 48 02 f0 01 a8 06 40 0c df cf 10 08 8f cf 10 23 ff cf 10 20 f3 00 40 23 f3 00 40 48 03 00 40 48 01 70 00 48 06 f0 03 2f c7 40 01 4f cf 10 25 af cf 10 20 33 0f 10 23 f3 00 40 43 f3 00 40 48 03 a0 40 48 05 10 05 88 06 60 03 2f cf 10 04 af cf 10 23 ff cf 10 21 f3 00 40 23 f3 00 40 48 03 00 40 48 0a 20 00 48 02 e0 01 0f c7 20 00 bf cf 10 29 8f cf 10 20 33 0f 10 20 f3 00 40 43 f3 00 40 48 03 80 40 48 04 f0 09 68 02 80 07 0f cf 10 0c 5f cf 10 23 ff cf 10 21 f3 00 00 20 f3 00 40 40 03 00 40 48 04 30 00 48 00 e0 02 20 07 00 06 9f cf 10 0d 6f cf 10 23 f0 0c cb e8 f6 80 56 79 0b fc c0 20 ba 7d 3a 6a 49 d3 d5 30 76 04 c5 29 e8 f9 9d 3a c5 84 db e8 b9 18 e7 80 d0 94 e1 5d 18 e5 19 1e 77 47 01 54 4d 21 a4 e4 f6 cd 34 20 18 8d 67 97 f8 46 56 96 9b 29 3a 04 cd 80 d8 68 a5 38 a1 a2 87 bb 6e 51 b4 29 36 82 f5 89 47 d2 d7 5c 50 0f 96 60 5d 0b 27 aa 97 a6 75 92 71 d9 bf a8 23 90 7c cb e0 02 de ef a8 90 20 f0 32 c3 c4 55 03
    
//
//    // print out for checking
//    fp = fopen("samples.csv", "w");
//    for (i = 433850; i < 442769; i++)
//    {
//        fprintf(fp, "%f\n", theta_buff[i]);
//    }
//    fclose(fp);
    
    // deallocate buffers
    free(i_buff);
    free(q_buff);
    free(theta_buff);
    free(delta_buff);
    
    printf("done\n");
    return EXIT_SUCCESS;
}
